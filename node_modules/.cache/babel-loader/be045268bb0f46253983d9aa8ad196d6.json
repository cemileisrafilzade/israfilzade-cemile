{"ast":null,"code":"import _pt from \"prop-types\";\nimport React, { useMemo, useCallback, useState, useEffect, useRef } from 'react';\nimport throttle from 'lodash.throttle';\nconst animatedClass = 'animate__animated';\nconst serverSide = typeof window === 'undefined';\nlet scrollableParentRefInitialValue = undefined;\n\nif (!serverSide) {\n  scrollableParentRefInitialValue = window;\n}\n\nexport const AnimationOnScroll = _ref => {\n  let {\n    offset = 150,\n    duration = 1,\n    style: styleProps,\n    className: classNameProps,\n    initiallyVisible = false,\n    animateIn,\n    afterAnimatedIn,\n    animateOut,\n    delay = 0,\n    animatePreScroll = true,\n    afterAnimatedOut,\n    scrollableParentSelector,\n    animateOnce = false,\n    children\n  } = _ref;\n  const [classes, setClasses] = useState(animatedClass);\n  const [style, setStyle] = useState({\n    animationDuration: `${duration}s`,\n    opacity: initiallyVisible ? 1 : 0\n  });\n  const node = useRef(null);\n  const animating = useRef(false);\n  const visibilityRef = useRef({\n    onScreen: false,\n    inViewport: false\n  });\n  const delayedAnimationTORef = useRef(undefined);\n  const callbackTORef = useRef(undefined);\n  const scrollableParentRef = useRef(scrollableParentRefInitialValue);\n  const getElementTop = useCallback(elm => {\n    let yPos = 0;\n\n    while (elm && elm.offsetTop !== undefined && elm.clientTop !== undefined) {\n      yPos += elm.offsetTop + elm.clientTop;\n      elm = elm.offsetParent;\n    }\n\n    return yPos;\n  }, []);\n  const getScrollPos = useCallback(() => {\n    if (scrollableParentRef.current.pageYOffset !== undefined) {\n      return scrollableParentRef.current.pageYOffset;\n    }\n\n    return scrollableParentRef.current.scrollTop;\n  }, [scrollableParentRef]);\n  const getScrollableParentHeight = useCallback(() => {\n    if (scrollableParentRef.current.innerHeight !== undefined) {\n      return scrollableParentRef.current.innerHeight;\n    }\n\n    return scrollableParentRef.current.clientHeight;\n  }, [scrollableParentRef]);\n  const getViewportTop = useCallback(() => {\n    return getScrollPos() + offset;\n  }, [offset, getScrollPos]);\n  const getViewportBottom = useCallback(() => {\n    return getScrollPos() + getScrollableParentHeight() - offset;\n  }, [offset, getScrollPos, getScrollableParentHeight]);\n  const isInViewport = useCallback(y => {\n    return y >= getViewportTop() && y <= getViewportBottom();\n  }, [getViewportTop, getViewportBottom]);\n  const isAboveViewport = useCallback(y => {\n    return y < getViewportTop();\n  }, [getViewportTop]);\n  const isBelowViewport = useCallback(y => {\n    return y > getViewportBottom();\n  }, [getViewportBottom]);\n  const inViewport = useCallback((elementTop, elementBottom) => {\n    return isInViewport(elementTop) || isInViewport(elementBottom) || isAboveViewport(elementTop) && isBelowViewport(elementBottom);\n  }, [isInViewport, isAboveViewport, isBelowViewport]);\n  const isAboveScreen = useCallback(y => {\n    return y < getScrollPos();\n  }, [getScrollPos]);\n  const isBelowScreen = useCallback(y => {\n    return y > getScrollPos() + getScrollableParentHeight();\n  }, [getScrollPos, getScrollableParentHeight]);\n  const onScreen = useCallback((elementTop, elementBottom) => {\n    return !isAboveScreen(elementBottom) && !isBelowScreen(elementTop);\n  }, [isAboveScreen, isBelowScreen]);\n  const getVisibility = useCallback(() => {\n    const elementTop = getElementTop(node.current) - getElementTop(scrollableParentRef.current);\n    const elementBottom = elementTop + node.current.clientHeight;\n    return {\n      inViewport: inViewport(elementTop, elementBottom),\n      onScreen: onScreen(elementTop, elementBottom)\n    };\n  }, [getElementTop, node, inViewport, onScreen, scrollableParentRef]);\n  const visibilityHasChanged = useCallback((previousVis, currentVis) => {\n    return previousVis.inViewport !== currentVis.inViewport || previousVis.onScreen !== currentVis.onScreen;\n  }, []);\n  const animate = useCallback((animation, callback) => {\n    delayedAnimationTORef.current = setTimeout(() => {\n      animating.current = true;\n      setClasses(`${animatedClass} ${animation}`);\n      setStyle({\n        animationDuration: `${duration}s`\n      });\n      callbackTORef.current = setTimeout(callback, duration * 1000);\n    }, delay);\n  }, [animating, delay, duration]);\n  const animateInTrigger = useCallback(callback => {\n    animate(animateIn, () => {\n      if (!animateOnce) {\n        setStyle({\n          animationDuration: `${duration}s`,\n          opacity: 1\n        });\n        animating.current = false;\n      }\n\n      const vis = getVisibility();\n\n      if (callback) {\n        callback(vis);\n      }\n    });\n  }, [animating, animateIn, animateOnce, duration, animate, getVisibility]);\n  const animateOutTrigger = useCallback(callback => {\n    animate(animateOut, () => {\n      setClasses(animatedClass);\n      setStyle({\n        animationDuration: `${duration}s`,\n        opacity: 0\n      });\n      const vis = getVisibility();\n\n      if (vis.inViewport && animateIn) {\n        animateInTrigger(afterAnimatedIn);\n      } else {\n        animating.current = false;\n      }\n\n      if (callback) {\n        callback(vis);\n      }\n    });\n  }, [animating, animate, animateIn, duration, afterAnimatedIn, animateInTrigger, animateOut, getVisibility]);\n  const handleScroll = useCallback(() => {\n    if (!animating.current) {\n      const {\n        current: visibility\n      } = visibilityRef;\n      const currentVis = getVisibility();\n\n      if (visibilityHasChanged(visibility, currentVis)) {\n        clearTimeout(delayedAnimationTORef.current);\n\n        if (!currentVis.onScreen) {\n          setClasses(animatedClass);\n          setStyle({\n            animationDuration: `${duration}s`,\n            opacity: initiallyVisible ? 1 : 0\n          });\n        } else if (currentVis.inViewport && animateIn) {\n          animateInTrigger(afterAnimatedIn);\n        } else if (currentVis.onScreen && visibility.inViewport && animateOut && node.current.style.opacity === '1') {\n          animateOutTrigger(afterAnimatedOut);\n        }\n\n        visibilityRef.current = currentVis;\n      }\n    }\n  }, [afterAnimatedIn, afterAnimatedOut, animateIn, animateInTrigger, animateOut, duration, initiallyVisible, visibilityHasChanged, animateOutTrigger, getVisibility]);\n  const listener = useMemo(() => throttle(() => {\n    handleScroll();\n  }, 50), [handleScroll]);\n  useEffect(() => {\n    if (!serverSide) {\n      const parentSelector = scrollableParentSelector;\n      scrollableParentRef.current = parentSelector ? document.querySelector(parentSelector) : window;\n\n      if (scrollableParentRef.current && scrollableParentRef.current.addEventListener) {\n        scrollableParentRef.current.addEventListener('scroll', listener);\n      } else {\n        console.warn(`Cannot find element by locator: ${scrollableParentSelector}`);\n      }\n\n      if (animatePreScroll) {\n        handleScroll();\n      }\n\n      return () => {\n        clearTimeout(delayedAnimationTORef.current);\n        clearTimeout(callbackTORef.current);\n\n        if (window && window.removeEventListener) {\n          window.removeEventListener('scroll', listener);\n        }\n      };\n    }\n  }, [handleScroll, scrollableParentSelector, scrollableParentRef, listener, animatePreScroll]);\n  return /*#__PURE__*/React.createElement(\"div\", {\n    ref: node,\n    className: classNameProps ? `${classNameProps} ${classes}` : classes,\n    style: Object.assign({}, style, styleProps)\n  }, children);\n};\nAnimationOnScroll.propTypes = {\n  offset: _pt.number,\n  duration: _pt.number,\n  style: _pt.any,\n  className: _pt.string,\n  initiallyVisible: _pt.bool,\n  animateIn: _pt.string,\n  afterAnimatedIn: _pt.any,\n  animateOut: _pt.string,\n  delay: _pt.number,\n  animatePreScroll: _pt.bool,\n  afterAnimatedOut: _pt.any,\n  scrollableParentSelector: _pt.string,\n  animateOnce: _pt.bool,\n  children: _pt.any\n};","map":{"version":3,"mappings":"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","names":["React","useMemo","useCallback","useState","useEffect","useRef","throttle","animatedClass","serverSide","window","scrollableParentRefInitialValue","undefined","AnimationOnScroll","offset","duration","style","styleProps","className","classNameProps","initiallyVisible","animateIn","afterAnimatedIn","animateOut","delay","animatePreScroll","afterAnimatedOut","scrollableParentSelector","animateOnce","children","classes","setClasses","setStyle","animationDuration","opacity","node","animating","visibilityRef","onScreen","inViewport","delayedAnimationTORef","callbackTORef","scrollableParentRef","getElementTop","elm","yPos","offsetTop","clientTop","offsetParent","getScrollPos","current","pageYOffset","scrollTop","getScrollableParentHeight","innerHeight","clientHeight","getViewportTop","getViewportBottom","isInViewport","y","isAboveViewport","isBelowViewport","elementTop","elementBottom","isAboveScreen","isBelowScreen","getVisibility","visibilityHasChanged","previousVis","currentVis","animate","animation","callback","setTimeout","animateInTrigger","vis","animateOutTrigger","handleScroll","visibility","clearTimeout","listener","parentSelector","document","querySelector","addEventListener","console","warn","removeEventListener","ref","Object","assign"],"sources":["C:\\Users\\Cemile\\Desktop\\portfolio\\for-learning\\node_modules\\react-animation-on-scroll\\src\\components\\AnimationOnScroll.tsx"],"sourcesContent":["import React, {\n  useMemo,\n  useCallback,\n  useState,\n  useEffect,\n  useRef,\n} from 'react';\nimport throttle from 'lodash.throttle';\n\nconst animatedClass = 'animate__animated';\nconst serverSide = typeof window === 'undefined';\n\nlet scrollableParentRefInitialValue: any = undefined;\nif (!serverSide) {\n  scrollableParentRefInitialValue = window;\n}\n\ntype Props = {\n  offset?: number;\n  duration?: number;\n  style?: any;\n  className?: string;\n  initiallyVisible?: boolean;\n  animateIn?: string;\n  afterAnimatedIn?: any;\n  animateOut?: string;\n  delay?: number;\n  animatePreScroll?: boolean;\n  afterAnimatedOut?: any;\n  scrollableParentSelector?: string;\n  animateOnce?: boolean;\n  children?: any;\n};\n\ntype styleProp = {\n  animationDuration: string;\n  opacity?: number;\n};\n\nexport const AnimationOnScroll = ({\n  offset = 150,\n  duration = 1,\n  style: styleProps,\n  className: classNameProps,\n  initiallyVisible = false,\n  animateIn,\n  afterAnimatedIn,\n  animateOut,\n  delay = 0,\n  animatePreScroll = true,\n  afterAnimatedOut,\n  scrollableParentSelector,\n  animateOnce = false,\n  children,\n}: Props) => {\n  const [classes, setClasses] = useState(animatedClass);\n  const [style, setStyle] = useState<styleProp>({\n    animationDuration: `${duration}s`,\n    opacity: initiallyVisible ? 1 : 0,\n  });\n\n  const node: { current: any } = useRef(null);\n  const animating: { current: boolean } = useRef(false);\n  const visibilityRef: {\n    current: { onScreen: boolean; inViewport: boolean };\n  } = useRef({ onScreen: false, inViewport: false });\n\n  const delayedAnimationTORef: { current: any } = useRef(undefined);\n  const callbackTORef: { current: any } = useRef(undefined);\n  const scrollableParentRef: { current: any } = useRef(scrollableParentRefInitialValue);\n\n  const getElementTop = useCallback((elm: any) => {\n    let yPos = 0;\n    while (elm && elm.offsetTop !== undefined && elm.clientTop !== undefined) {\n      yPos += elm.offsetTop + elm.clientTop;\n      elm = elm.offsetParent;\n    }\n    return yPos;\n  }, []);\n\n  const getScrollPos = useCallback(() => {\n    if (scrollableParentRef.current.pageYOffset !== undefined) {\n      return scrollableParentRef.current.pageYOffset;\n    }\n    return scrollableParentRef.current.scrollTop;\n  }, [scrollableParentRef]);\n\n  const getScrollableParentHeight = useCallback(() => {\n    if (scrollableParentRef.current.innerHeight !== undefined) {\n      return scrollableParentRef.current.innerHeight;\n    }\n    return scrollableParentRef.current.clientHeight;\n  }, [scrollableParentRef]);\n\n  const getViewportTop = useCallback(() => {\n    return getScrollPos() + offset;\n  }, [offset, getScrollPos]);\n\n  const getViewportBottom = useCallback(() => {\n    return getScrollPos() + getScrollableParentHeight() - offset;\n  }, [offset, getScrollPos, getScrollableParentHeight]);\n\n  const isInViewport = useCallback(\n    (y) => {\n      return y >= getViewportTop() && y <= getViewportBottom();\n    },\n    [getViewportTop, getViewportBottom]\n  );\n\n  const isAboveViewport = useCallback(\n    (y) => {\n      return y < getViewportTop();\n    },\n    [getViewportTop]\n  );\n\n  const isBelowViewport = useCallback(\n    (y) => {\n      return y > getViewportBottom();\n    },\n    [getViewportBottom]\n  );\n\n  const inViewport = useCallback(\n    (elementTop, elementBottom) => {\n      return (\n        isInViewport(elementTop) ||\n        isInViewport(elementBottom) ||\n        (isAboveViewport(elementTop) && isBelowViewport(elementBottom))\n      );\n    },\n    [isInViewport, isAboveViewport, isBelowViewport]\n  );\n\n  const isAboveScreen = useCallback(\n    (y) => {\n      return y < getScrollPos();\n    },\n    [getScrollPos]\n  );\n\n  const isBelowScreen = useCallback(\n    (y) => {\n      return y > getScrollPos() + getScrollableParentHeight();\n    },\n    [getScrollPos, getScrollableParentHeight]\n  );\n\n  const onScreen = useCallback(\n    (elementTop, elementBottom) => {\n      return !isAboveScreen(elementBottom) && !isBelowScreen(elementTop);\n    },\n    [isAboveScreen, isBelowScreen]\n  );\n\n  const getVisibility = useCallback(() => {\n    const elementTop =\n      getElementTop(node.current) - getElementTop(scrollableParentRef.current);\n    const elementBottom = elementTop + node.current.clientHeight;\n\n    return {\n      inViewport: inViewport(elementTop, elementBottom),\n      onScreen: onScreen(elementTop, elementBottom),\n    };\n  }, [getElementTop, node, inViewport, onScreen, scrollableParentRef]);\n\n  const visibilityHasChanged = useCallback((previousVis, currentVis) => {\n    return (\n      previousVis.inViewport !== currentVis.inViewport ||\n      previousVis.onScreen !== currentVis.onScreen\n    );\n  }, []);\n\n  const animate = useCallback(\n    (animation, callback) => {\n      delayedAnimationTORef.current = setTimeout(() => {\n        animating.current = true;\n        setClasses(`${animatedClass} ${animation}`);\n        setStyle({ animationDuration: `${duration}s` });\n        callbackTORef.current = setTimeout(callback, duration * 1000);\n      }, delay);\n    },\n    [animating, delay, duration]\n  );\n\n  const animateInTrigger = useCallback(\n    (callback) => {\n      animate(animateIn, () => {\n        if (!animateOnce) {\n          setStyle({\n            animationDuration: `${duration}s`,\n            opacity: 1,\n          });\n          animating.current = false;\n        }\n        const vis = getVisibility();\n        if (callback) {\n          callback(vis);\n        }\n      });\n    },\n    [animating, animateIn, animateOnce, duration, animate, getVisibility]\n  );\n\n  const animateOutTrigger = useCallback(\n    (callback) => {\n      animate(animateOut, () => {\n        setClasses(animatedClass);\n        setStyle({ animationDuration: `${duration}s`, opacity: 0 });\n        const vis = getVisibility();\n\n        if (vis.inViewport && animateIn) {\n          animateInTrigger(afterAnimatedIn);\n        } else {\n          animating.current = false;\n        }\n\n        if (callback) {\n          callback(vis);\n        }\n      });\n    },\n    [\n      animating,\n      animate,\n      animateIn,\n      duration,\n      afterAnimatedIn,\n      animateInTrigger,\n      animateOut,\n      getVisibility,\n    ]\n  );\n\n  const handleScroll = useCallback(() => {\n    if (!animating.current) {\n      const { current: visibility } = visibilityRef;\n      const currentVis = getVisibility();\n      if (visibilityHasChanged(visibility, currentVis)) {\n        clearTimeout(delayedAnimationTORef.current);\n        if (!currentVis.onScreen) {\n          setClasses(animatedClass);\n          setStyle({\n            animationDuration: `${duration}s`,\n            opacity: initiallyVisible ? 1 : 0,\n          });\n        } else if (currentVis.inViewport && animateIn) {\n          animateInTrigger(afterAnimatedIn);\n        } else if (\n          currentVis.onScreen &&\n          visibility.inViewport &&\n          animateOut &&\n          node.current.style.opacity === '1'\n        ) {\n          animateOutTrigger(afterAnimatedOut);\n        }\n        visibilityRef.current = currentVis;\n      }\n    }\n  }, [\n    afterAnimatedIn,\n    afterAnimatedOut,\n    animateIn,\n    animateInTrigger,\n    animateOut,\n    duration,\n    initiallyVisible,\n    visibilityHasChanged,\n    animateOutTrigger,\n    getVisibility,\n  ]);\n\n  const listener = useMemo(\n    () =>\n      throttle(() => {\n        handleScroll();\n      }, 50),\n    [handleScroll]\n  );\n\n  useEffect(() => {\n    if (!serverSide) {\n      const parentSelector = scrollableParentSelector;\n      scrollableParentRef.current = parentSelector\n        ? document.querySelector(parentSelector)\n        : window;\n      if (\n        scrollableParentRef.current &&\n        scrollableParentRef.current.addEventListener\n      ) {\n        scrollableParentRef.current.addEventListener('scroll', listener);\n      } else {\n        console.warn(\n          `Cannot find element by locator: ${scrollableParentSelector}`\n        );\n      }\n      if (animatePreScroll) {\n        handleScroll();\n      }\n\n      return () => {\n        clearTimeout(delayedAnimationTORef.current);\n        clearTimeout(callbackTORef.current);\n        if (window && window.removeEventListener) {\n          window.removeEventListener('scroll', listener);\n        }\n      };\n    }\n  }, [\n    handleScroll,\n    scrollableParentSelector,\n    scrollableParentRef,\n    listener,\n    animatePreScroll,\n  ]);\n\n  return (\n    <div\n      ref={node}\n      className={classNameProps ? `${classNameProps} ${classes}` : classes}\n      style={Object.assign({}, style, styleProps)}\n    >\n      {children}\n    </div>\n  );\n};\n"]},"metadata":{},"sourceType":"module"}